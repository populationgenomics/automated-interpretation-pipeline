"""
Read, filter, annotate, classify, and write Genetic data
- read MT
- read PanelApp data through GCP client
- hard-filter (FILTERS, AC)
- extract generic fields
- remove all rows and consequences not relevant to GREEN genes
- extract vep data into CSQ string(s)
- annotate with categories 1, 2, 3, 4, 5, and Support
- remove un-categorised variants
- write as VCF
This doesn't include applying inheritance pattern filters
Categories applied here are treated as unconfirmed
"""


import os
import logging
import sys
from argparse import ArgumentParser

import hail as hl
from peddy import Ped

from cpg_utils import to_path
from cpg_utils.config import get_config
from cpg_utils.hail_batch import init_batch, output_path

from reanalysis.hail_audit import fields_audit, vep_audit
from reanalysis.utils import read_json_from_path


# set some Hail constants
MISSING_INT = hl.int32(0)
MISSING_FLOAT_LO = hl.float64(0.0)
MISSING_FLOAT_HI = hl.float64(1.0)
MISSING_STRING = hl.str('missing')
ONE_INT = hl.int32(1)
BENIGN = hl.str('benign')
CONFLICTING = hl.str('conflicting')
LOFTEE_HC = hl.str('HC')
PATHOGENIC = hl.str('pathogenic')

BASE_FIELDS_REQUIRED = [
    ('locus', hl.LocusExpression),
    ('alleles', hl.ArrayExpression),
    ('AC', hl.Int32Expression),
    ('AF', hl.Float64Expression),
    ('AN', hl.Int32Expression),
]
FIELDS_REQUIRED = {
    'splice_ai': [
        ('delta_score', hl.Float32Expression),
        ('splice_consequence', hl.StringExpression),
    ],
    'gnomad_exomes': [
        ('AF', hl.Float64Expression),
        ('AN', hl.Int32Expression),
        ('AC', hl.Int32Expression),
        ('Hom', hl.Int32Expression),
        ('Hemi', hl.Int32Expression),
    ],
    'gnomad_genomes': [
        ('AF', hl.Float64Expression),
        ('AN', hl.Int32Expression),
        ('AC', hl.Int32Expression),
        ('Hom', hl.Int32Expression),
        ('Hemi', hl.Int32Expression),
    ],
    'cadd': [('PHRED', hl.Float32Expression)],
    'dbnsfp': [
        ('REVEL_score', hl.StringExpression),
        ('MutationTaster_pred', hl.StringExpression),
    ],
    'clinvar': [
        ('clinical_significance', hl.StringExpression),
        ('gold_stars', hl.Int32Expression),
    ],
    'geneIds': [],
}

VEP_TX_FIELDS_REQUIRED = [
    ('variant_allele', hl.StringExpression),
    ('consequence_terms', hl.ArrayExpression),
    ('transcript_id', hl.StringExpression),
    ('protein_id', hl.StringExpression),
    ('gene_id', hl.StringExpression),
    ('gene_symbol', hl.StringExpression),
    ('gene_symbol_source', hl.StringExpression),
    ('canonical', hl.Int32Expression),
    ('cdna_start', hl.Int32Expression),
    ('cds_start', hl.Int32Expression),
    ('cds_end', hl.Int32Expression),
    ('biotype', hl.StringExpression),
    ('protein_start', hl.Int32Expression),
    ('protein_end', hl.Int32Expression),
    ('sift_score', hl.Float64Expression),
    ('sift_prediction', hl.StringExpression),
    ('polyphen_score', hl.Float64Expression),
    ('mane_select', hl.StringExpression),
    ('lof', hl.StringExpression),
]


def annotate_aip_clinvar(mt: hl.MatrixTable, clinvar: str) -> hl.MatrixTable:
    """
    instead of making a separate decision about whether the clinvar
    annotation(s) are meaningful during each test, add a single value
    early on. This accomplishes two things:
    1. reduces the logic of each individual test
    2. allows us to use other clinvar consequences for this codon
        (see issue #140)
    3. allows us to replace the clinvar annotation with our private
        annotations (see issue #147)
    Args:
        mt (): the MatrixTable of all variants
        clinvar (str): path to custom table
    Returns:
        The same MatrixTable but with additional annotations
    """

    # if there's private clinvar annotations - use them
    if clinvar != 'absent':
        logging.info(f'loading private clinvar annotations from {clinvar}')
        ht = hl.read_table(clinvar)
        mt = mt.annotate_rows(
            info=mt.info.annotate(
                clinvar_sig=hl.or_else(ht[mt.row_key].rating, MISSING_STRING),
                clinvar_stars=hl.or_else(ht[mt.row_key].stars, MISSING_INT),
                clinvar_allele=hl.or_else(ht[mt.row_key].allele_id, MISSING_STRING),
            )
        )

        # remove all confident benign (only confident in this ht)
        mt = mt.filter_rows(mt.info.clinvar_sig.lower().contains(BENIGN), keep=False)

    # use default annotations
    else:
        logging.info(f'no private annotations, using default contents')

        # do this annotation first, as hail can't string filter against
        # missing contents
        mt = mt.annotate_rows(
            info=mt.info.annotate(
                clinvar_sig=hl.or_else(
                    mt.clinvar.clinical_significance, MISSING_STRING
                ),
                clinvar_stars=hl.or_else(mt.clinvar.gold_stars, MISSING_INT),
                clinvar_allele=hl.or_else(mt.clinvar.allele_id, MISSING_INT),
            )
        )

        # remove all confidently benign
        mt = mt.filter_rows(
            (mt.info.clinvar_sig.lower().contains(BENIGN))
            & (mt.info.clinvar_stars > 0),
            keep=False,
        )

    # annotate as either strong or regular
    mt = mt.annotate_rows(
        info=mt.info.annotate(
            clinvar_aip=hl.if_else(
                (
                    (mt.info.clinvar_sig.lower().contains(PATHOGENIC))
                    & ~(mt.info.clinvar_sig.lower().contains(CONFLICTING))
                ),
                ONE_INT,
                MISSING_INT,
            ),
            clinvar_aip_strong=hl.if_else(
                (
                    (mt.info.clinvar_sig.lower().contains(PATHOGENIC))
                    & ~(mt.info.clinvar_sig.lower().contains(CONFLICTING))
                    & (mt.info.clinvar_stars > 0)
                ),
                ONE_INT,
                MISSING_INT,
            ),
        )
    )

    return mt


def filter_matrix_by_ac(
    mt: hl.MatrixTable, ac_threshold: float | None = 0.01
) -> hl.MatrixTable:
    """
    Remove variants with AC in joint-call over threshold
    :param mt:
    :param ac_threshold:
    :return: reduced MatrixTable
    """
    return mt.filter_rows((mt.AC <= 5) | (mt.AC / mt.AN < ac_threshold))


def filter_on_quality_flags(mt: hl.MatrixTable) -> hl.MatrixTable:
    """
    filter MT to rows with 0 quality filters
    note: in Hail, PASS is represented as an empty set
    :param mt:
    """
    return mt.filter_rows(mt.filters.length() == 0)


def filter_to_well_normalised(mt: hl.MatrixTable) -> hl.MatrixTable:
    """
    single alt per row, no missing Alt
    :param mt:
    """
    return mt.filter_rows((hl.len(mt.alleles) == 2) & (mt.alleles[1] != '*'))


def annotate_category_1(mt: hl.MatrixTable) -> hl.MatrixTable:
    """
    applies the boolean Category1 annotation
    semi-rare in Gnomad
    at least one Clinvar star
    contains pathogenic and not conflicting; doesn't contain benign
    :param mt:
    :return: same Matrix, with additional field per variant
    """

    return mt.annotate_rows(
        info=mt.info.annotate(
            categoryboolean1=hl.if_else(
                mt.info.clinvar_aip_strong == ONE_INT,
                ONE_INT,
                MISSING_INT,
            )
        )
    )


def annotate_category_2(
    mt: hl.MatrixTable, new_genes: hl.SetExpression
) -> hl.MatrixTable:
    """
    - Gene is new in PanelApp
    - Clinvar contains pathogenic, or
    - Critical protein consequence on at least one transcript
    - High in silico consequence
    :param mt:
    :param new_genes: the new genes in this panelapp content
    :return: same Matrix, with additional field per variant
    """

    critical_consequences = hl.set(get_config()['filter']['critical_csq'])

    # check for new - if new, allow for in silico, CSQ, or clinvar to confirm
    return mt.annotate_rows(
        info=mt.info.annotate(
            categoryboolean2=hl.if_else(
                (new_genes.contains(mt.geneIds))
                & (
                    (
                        hl.len(
                            mt.vep.transcript_consequences.filter(
                                lambda x: hl.len(
                                    critical_consequences.intersection(
                                        hl.set(x.consequence_terms)
                                    )
                                )
                                > 0
                            )
                        )
                        > 0
                    )
                    | (mt.info.clinvar_aip == ONE_INT)
                    | (
                        (mt.info.cadd > get_config()['filter']['cadd'])
                        | (mt.info.revel > get_config()['filter']['revel'])
                    )
                ),
                ONE_INT,
                MISSING_INT,
            )
        )
    )


def annotate_category_3(mt: hl.MatrixTable) -> hl.MatrixTable:
    """
    applies the boolean Category3 flag
    - Critical protein consequence on at least one transcript
    - either predicted NMD or
    - any star Pathogenic or Likely_pathogenic in Clinvar
    :param mt:
    :return:
    """

    critical_consequences = hl.set(get_config()['filter']['critical_csq'])

    # First check if we have any HIGH consequences
    # then explicitly link the LOFTEE check with HIGH consequences
    # OR allow for a pathogenic ClinVar, any Stars
    return mt.annotate_rows(
        info=mt.info.annotate(
            categoryboolean3=hl.if_else(
                (
                    hl.len(
                        mt.vep.transcript_consequences.filter(
                            lambda x: (
                                hl.len(
                                    critical_consequences.intersection(
                                        hl.set(x.consequence_terms)
                                    )
                                )
                                > 0
                            )
                        )
                    )
                    > 0
                )
                & (
                    (
                        hl.len(
                            mt.vep.transcript_consequences.filter(
                                lambda x: (
                                    hl.len(
                                        critical_consequences.intersection(
                                            hl.set(x.consequence_terms)
                                        )
                                    )
                                    > 0
                                )
                                & ((x.lof == LOFTEE_HC) | (hl.is_missing(x.lof)))
                            )
                        )
                        > 0
                    )
                    | (mt.info.clinvar_aip == ONE_INT)
                ),
                ONE_INT,
                MISSING_INT,
            )
        )
    )


def filter_by_consequence(mt: hl.MatrixTable) -> hl.MatrixTable:
    """
    - reduce the per-row transcript CSQ to a limited group
    - reduce the rows to ones where there are remaining tx consequences
    :param mt:
    :return: reduced matrix
    """

    # at time of writing this is VEP HIGH + missense_variant
    # update without updating the dictionary content
    critical_consequences = set(get_config()['filter']['critical_csq'])
    additional_consequences = set(get_config()['filter']['additional_csq'])
    critical_consequences.update(additional_consequences)

    # overwrite the consequences with an intersection against a limited list
    mt = mt.annotate_rows(
        vep=mt.vep.annotate(
            transcript_consequences=mt.vep.transcript_consequences.filter(
                lambda x: hl.len(
                    hl.set(x.consequence_terms).intersection(critical_consequences)
                )
                > 0
            )
        )
    )

    # filter out rows with no tx consequences left, and no splice cat. assignment
    return mt.filter_rows(
        (hl.len(mt.vep.transcript_consequences) > 0) & (mt.info.categoryboolean5 == 0)
    )


def annotate_category_4(mt: hl.MatrixTable, plink_family_file: str) -> hl.MatrixTable:
    """
    Category based on de novo MOI, restricted to a group of consequences
    uses the Hail builtin method (very strict)

    :param mt: the whole joint-call MatrixTable
    :param plink_family_file: path to a pedigree in PLINK format
    :return: mt with Category4 annotations
    """

    logging.info('Running de novo search')

    de_novo_matrix = filter_by_consequence(mt)

    pedigree = hl.Pedigree.read(plink_family_file)

    dn_table = hl.de_novo(
        de_novo_matrix,
        pedigree,
        pop_frequency_prior=de_novo_matrix.info.gnomad_af,
        ignore_in_sample_allele_frequency=True,
    )

    # re-key the table by locus,alleles, removing the sampleID from the compound key
    dn_table = dn_table.key_by(dn_table.locus, dn_table.alleles)

    # we only require the key (locus, alleles) and the sample ID
    # select to remove other fields, then collect per-key into Array of Structs
    dn_table = dn_table.select(dn_table.id).collect_by_key()

    # collect all sample IDs per locus, and squash into a String Array
    # delimit to compress that Array into single Strings
    dn_table = dn_table.annotate(
        values=hl.delimit(hl.map(lambda x: x.id, dn_table.values), ',')
    )

    # log the number of variants found this way
    logging.info(f'{dn_table.count()} variants showed de novo inheritance')

    # annotate those values as a flag if relevant, else 'missing'
    return mt.annotate_rows(
        info=mt.info.annotate(
            **{
                'categorysample4': hl.or_else(
                    dn_table[mt.row_key].values, MISSING_STRING
                )
            }
        )
    )


def annotate_category_5(mt: hl.MatrixTable) -> hl.MatrixTable:
    """
    :param mt:
    :return: same Matrix, with additional field per variant
    """

    return mt.annotate_rows(
        info=mt.info.annotate(
            categoryboolean5=hl.if_else(
                mt.info.splice_ai_delta >= get_config()['filter']['spliceai'],
                ONE_INT,
                MISSING_INT,
            )
        )
    )


def annotate_category_support(mt: hl.MatrixTable) -> hl.MatrixTable:
    """
    Background class based on in silico annotations
    - rare in Gnomad, and
    - CADD & REVEL above threshold (switched to consensus), or
    - Massive cross-tool consensus
    - polyphen and sift are evaluated per-consequence
    The intention is that this class will never be the sole reason to treat a variant
    as interesting, but can be used as a broader class with a lower barrier to entry
    Goal is to have a broader set of variants to find Comp-Hets.
    This support category can be expanded to encompass other scenarios that qualify
    variants as 'of second-hit interest only'
    :param mt:
    :return:
    """

    return mt.annotate_rows(
        info=mt.info.annotate(
            categorysupport=hl.if_else(
                (
                    (mt.info.cadd > get_config()['filter'].get('cadd'))
                    & (mt.info.revel > get_config()['filter'].get('revel'))
                )
                | (
                    (
                        mt.vep.transcript_consequences.any(
                            lambda x: hl.or_else(x.sift_score, MISSING_FLOAT_HI)
                            <= get_config()['filter'].get('sift')
                        )
                    )
                    & (
                        mt.vep.transcript_consequences.any(
                            lambda x: hl.or_else(x.polyphen_score, MISSING_FLOAT_LO)
                            >= get_config()['filter'].get('polyphen')
                        )
                    )
                    & (
                        (mt.info.mutationtaster.contains('D'))
                        | (mt.info.mutationtaster == 'missing')
                    )
                ),
                ONE_INT,
                MISSING_INT,
            )
        )
    )


def filter_to_population_rare(mt: hl.MatrixTable) -> hl.MatrixTable:
    """
    run the rare filter, using Gnomad Exomes and Genomes
    allow clinvar pathogenic to slip through this filter
    """
    # gnomad exomes and genomes below threshold or missing
    # if missing they were previously replaced with 0.0
    # 'semi-rare' as dominant filters will be more strictly filtered later
    rare_af_threshold = get_config()['filter']['af_semi_rare']
    return mt.filter_rows(
        (
            (mt.info.gnomad_ex_af < rare_af_threshold)
            & (mt.info.gnomad_af < rare_af_threshold)
        )
        | (mt.info.clinvar_aip == ONE_INT)
    )


def split_rows_by_gene_and_filter_to_green(
    mt: hl.MatrixTable, green_genes: hl.SetExpression
) -> hl.MatrixTable:
    """
    splits each GeneId onto a new row, then filters any
    rows not annotating a Green PanelApp gene
    :param mt:
    :param green_genes:
    """

    # split each gene onto a separate row
    # transforms 'geneIds' field from set to string
    mt = mt.explode_rows(mt.geneIds)

    # filter rows without a green gene (removes empty geneIds)
    mt = mt.filter_rows(green_genes.contains(mt.geneIds))

    # limit the per-row transcript CSQ to those relevant to the single
    # gene now present on each row
    mt = mt.annotate_rows(
        vep=mt.vep.annotate(
            transcript_consequences=mt.vep.transcript_consequences.filter(
                lambda x: (mt.geneIds == x.gene_id)
                & ((x.biotype == 'protein_coding') | (x.mane_select.contains('NM')))
            )
        )
    )

    return mt


def vep_struct_to_csq(vep_expr: hl.expr.StructExpression) -> hl.expr.ArrayExpression:
    """
    Taken shamelessly from the gnomad library source code
    Given a VEP Struct, returns an array of VEP VCF CSQ strings
    (1 per csq in the struct).
    Fields & order correspond to those in `csq_fields`, corresponding to the
    VCF header that is required to interpret the VCF CSQ INFO field.
    Order is flexible & all fields in the default value are supported.
    These fields are formatted in the same way that their VEP CSQ counterparts are.
    :param vep_expr: The input VEP Struct
    :return: The corresponding CSQ string(s)
    """

    def get_csq_from_struct(
        element: hl.expr.StructExpression,
    ) -> hl.expr.StringExpression:

        # Most fields are 1-1, just lowercase
        fields = dict(element)

        # Add general exceptions
        fields.update(
            {
                'consequence': hl.delimit(element.consequence_terms, delimiter='&'),
                'feature': element.transcript_id,
                'variant_class': vep_expr.variant_class,
                'ensp': element.protein_id,
                'gene': element.gene_id,
                'symbol': element.gene_symbol,
                'sift': element.sift_prediction
                + '('
                + hl.format('%.3f', element.sift_score)
                + ')',
                'polyphen': element.polyphen_prediction
                + '('
                + hl.format('%.3f', element.polyphen_score)
                + ')',
                'mane_select': element.mane_select,
            }
        )

        # pull the required fields and ordering from config
        csq_fields = get_config()['csq']['csq_string']

        return hl.delimit(
            [hl.or_else(hl.str(fields.get(f, '')), '') for f in csq_fields], '|'
        )

    csq = hl.empty_array(hl.tstr)
    # pylint: disable=unnecessary-lambda
    csq = csq.extend(
        hl.or_else(
            vep_expr['transcript_consequences'].map(lambda x: get_csq_from_struct(x)),
            hl.empty_array(hl.tstr),
        )
    )

    # previous consequence filters may make this caution unnecessary
    return hl.or_missing(hl.len(csq) > 0, csq)


def extract_annotations(mt: hl.MatrixTable) -> hl.MatrixTable:
    """
    pull out select fields which aren't per-consequence
    store these in INFO (required to be included in VCF export)
    replace with placeholder (least consequential) if empty
    e.g. most tools score 0, but for Sift 1 is least important
    :param mt:
    :return: input matrix with annotations pulled into INFO
    """

    logging.info('Pulling VEP annotations into INFO field')

    return mt.annotate_rows(
        info=mt.info.annotate(
            AC=hl.or_else(mt.AC, MISSING_INT),
            AN=hl.or_else(mt.AN, MISSING_INT),
            gnomad_ex_af=hl.or_else(mt.gnomad_exomes.AF, MISSING_FLOAT_LO),
            gnomad_ex_an=hl.or_else(mt.gnomad_exomes.AN, MISSING_INT),
            gnomad_ex_ac=hl.or_else(mt.gnomad_exomes.AC, MISSING_INT),
            gnomad_ex_hom=hl.or_else(mt.gnomad_exomes.Hom, MISSING_INT),
            gnomad_ex_hemi=hl.or_else(mt.gnomad_exomes.Hemi, MISSING_INT),
            gnomad_af=hl.or_else(mt.gnomad_genomes.AF, MISSING_FLOAT_LO),
            gnomad_an=hl.or_else(mt.gnomad_genomes.AN, MISSING_INT),
            gnomad_ac=hl.or_else(mt.gnomad_genomes.AC, MISSING_INT),
            gnomad_hom=hl.or_else(mt.gnomad_genomes.Hom, MISSING_INT),
            gnomad_hemi=hl.or_else(mt.gnomad_genomes.Hemi, MISSING_INT),
            splice_ai_delta=hl.or_else(mt.splice_ai.delta_score, MISSING_FLOAT_LO),
            splice_ai_csq=hl.or_else(
                mt.splice_ai.splice_consequence, MISSING_STRING
            ).replace(' ', '_'),
            cadd=hl.or_else(mt.cadd.PHRED, MISSING_FLOAT_LO),
            # these next 3 are per-transcript, with ';' to delimit
            # pulling these annotations into INFO with ';' to separate
            # will break INFO parsing for most tools
            revel=hl.float64(hl.or_else(mt.dbnsfp.REVEL_score, '0.0')),
            mutationtaster=hl.or_else(
                mt.dbnsfp.MutationTaster_pred, MISSING_STRING
            ).replace(';', ','),
        )
    )


def filter_to_categorised(mt: hl.MatrixTable) -> hl.MatrixTable:
    """
    Filter to rows tagged with a class
    :param mt:
    :return: input matrix, minus rows without Categories applied
    """
    return mt.filter_rows(
        (mt.info.categoryboolean1 == 1)
        | (mt.info.categoryboolean2 == 1)
        | (mt.info.categoryboolean3 == 1)
        | (mt.info.categorysample4 != 'missing')
        | (mt.info.categoryboolean5 == 1)
        | (mt.info.categorysupport == 1)
    )


def write_matrix_to_vcf(mt: hl.MatrixTable):
    """
    write the remaining MatrixTable content to file as a VCF

    Args:
        mt (): the whole MatrixTable

    Returns:
        path to write MT out to
    """

    # this temp file needs to be in GCP, not local
    # otherwise the batch that generates the file won't be able to read
    additional_cloud_path = output_path('additional_header.txt', 'tmp')
    with to_path(additional_cloud_path).open('w') as handle:
        handle.write(
            '##INFO=<ID=CSQ,Number=.,Type=String,Description="Format: '
            'allele|consequence|symbol|gene|feature|mane_select|biotype|exon|hgvsc|'
            'hgvsp|cdna_position|cds_position|protein_position|amino_acids|codons|'
            'allele_num|variant_class|tsl|appris|ccds|ensp|swissprot|trembl|uniparc|'
            'gene_pheno|sift|polyphen|lof|lof_filter|lof_flags">'
        )
    vcf_out = output_path('hail_categorised.vcf.bgz')
    logging.info(f'Writing categorised variants out to {vcf_out}')
    hl.export_vcf(mt, vcf_out, append_to_header=additional_cloud_path, tabix=True)


def green_and_new_from_panelapp(
    panel_genes: dict[str, dict[str, str]]
) -> tuple[hl.SetExpression, hl.SetExpression]:
    """
    Pull all ENSGs from PanelApp data relating to Green Genes
    Also identify the subset of those genes which relate to NEW in panel

    Args:
        panel_genes (): the 'genes' contents from the panelapp dictionary

    Returns:
        two set expressions - Green, and (Green and New) genes
    """

    # take all the green genes, remove the metadata
    green_genes = set(panel_genes.keys())
    logging.info(f'Extracted {len(green_genes)} green genes')
    green_gene_set_expression = hl.literal(green_genes)

    new_genes = {
        gene for gene in green_genes if len(panel_genes[gene].get('new', [])) > 0
    }
    logging.info(f'Extracted {len(new_genes)} NEW genes')
    new_gene_set_expression = hl.literal(new_genes)

    return green_gene_set_expression, new_gene_set_expression


def checkpoint_and_repartition(
    mt: hl.MatrixTable,
    checkpoint_root: str,
    checkpoint_num: int,
    extra_logging: str | None = '',
) -> hl.MatrixTable:
    """
    uses estimated row data size to repartition MT
    aiming for a target partition size of ~10MB
    Kat's thread:
    https://discuss.hail.is/t/best-way-to-repartition-heavily-filtered-matrix-tables/2140

    Args:
        mt (): All data
        checkpoint_root (): where to write the checkpoint to
        checkpoint_num (): the checkpoint increment (insert into file path)
        extra_logging (): informative statement to add to logging counts/partitions

    Returns:
        the MT after checkpointing, re-reading, and repartitioning
    """
    checkpoint_extended = f'{checkpoint_root}_{checkpoint_num}'
    logging.info(f'Checkpointing MT to {checkpoint_extended}')
    mt = mt.checkpoint(checkpoint_extended, overwrite=True)

    # estimate partitions; fall back to 1 if low row count
    current_rows = mt.count_rows()
    partitions = current_rows // 200000 or 1

    logging.info(
        f'Re-partitioning {current_rows} into {partitions} partitions {extra_logging}'
    )

    return mt.repartition(n_partitions=partitions, shuffle=True)


def subselect_mt_to_pedigree(mt: hl.MatrixTable, pedigree: str) -> hl.MatrixTable:
    """
    remove any columns from the MT which are not represented in the Pedigree

    Args:
        mt ():
        pedigree ():

    Returns:

    """

    # individual IDs from pedigree
    peddy_ped = Ped(pedigree)
    ped_samples = {individual.sample_id for individual in peddy_ped.samples()}

    # individual IDs from matrix
    matrix_samples = set(mt.s.collect())

    # find overlapping samples
    common_samples = ped_samples.intersection(matrix_samples)

    logging.info(f'Samples in Pedigree: {len(ped_samples)}')
    logging.info(f'Samples in MatrixTable: {len(matrix_samples)}')
    logging.info(f'Common Samples: {len(common_samples)}')

    if len(common_samples) == 0:
        raise Exception('No samples shared between pedigree and MT')

    # full overlap = no filtering
    if common_samples == matrix_samples:
        return mt

    # reduce to those common samples
    mt = mt.filter_cols(hl.literal(common_samples).contains(mt.s))

    logging.info(f'Remaining MatrixTable columns: {mt.count_cols()}')

    return mt


def main(mt_path: str, panelapp: str, plink: str, clinvar: str):
    """
    Read MT, filter, and apply category annotation
    Export as a VCF

    Args:
        mt_path (str):
        panelapp ():
        plink ():
        clinvar ():
    """

    # initiate Hail with defined driver spec.
    init_batch(driver_cores=8, driver_memory='highmem')

    # checkpoints should be kept independent
    checkpoint_number = 0

    # get the run configuration JSON
    logging.info(f'Reading config dict from {os.getenv("CPG_CONFIG_PATH")}')

    # get temp suffix from the config (can be None or missing)
    checkpoint_root = output_path(
        'hail_matrix.mt', get_config()['buckets'].get('tmp_suffix')
    )

    # read the parsed panelapp data
    logging.info(f'Reading PanelApp data from "{panelapp}"')
    panelapp = read_json_from_path(panelapp)['genes']

    # pull green and new genes from the panelapp data
    green_expression, new_expression = green_and_new_from_panelapp(panelapp)

    logging.info('Starting Hail with reference genome GRCh38')

    # if we already generated the annotated output, load instead
    if not to_path(mt_path.rstrip('/') + '/').exists():
        raise Exception(f'Input MatrixTable doesn\'t exist: {mt_path}')

    mt = hl.read_matrix_table(mt_path)

    if not (
        fields_audit(
            mt, base_fields=BASE_FIELDS_REQUIRED, nested_fields=FIELDS_REQUIRED
        )
        and vep_audit(mt, VEP_TX_FIELDS_REQUIRED)
    ):
        raise Exception('Fields were missing from the input Matrix')

    # subset to currently considered samples
    mt = subselect_mt_to_pedigree(mt, pedigree=plink)

    logging.debug(
        f'Loaded annotated MT from {mt_path}, size: {mt.count_rows()}',
    )

    # filter out quality failures
    mt = filter_on_quality_flags(mt)

    # running global quality filter steps
    mt = filter_matrix_by_ac(mt=mt)
    mt = filter_to_well_normalised(mt)

    # die if there are no variants remaining
    if mt.count_rows() == 0:
        raise Exception('No remaining rows to process!')

    mt = checkpoint_and_repartition(
        mt,
        checkpoint_root=checkpoint_root,
        checkpoint_num=checkpoint_number,
        extra_logging='after applying quality filters',
    )

    checkpoint_number = checkpoint_number + 1

    # swap out the default clinvar annotations with private clinvar
    mt = annotate_aip_clinvar(mt, clinvar)
    mt = extract_annotations(mt)

    mt = filter_to_population_rare(mt=mt)
    mt = split_rows_by_gene_and_filter_to_green(mt=mt, green_genes=green_expression)

    mt = checkpoint_and_repartition(
        mt,
        checkpoint_root=checkpoint_root,
        checkpoint_num=checkpoint_number,
        extra_logging='after applying Rare & Green-Gene filters',
    )

    checkpoint_number = checkpoint_number + 1

    # add Classes to the MT
    # current logic is to apply 1, 2, 3, and 5, then 4 (de novo)
    # for cat. 4, pre-filter the variants by tx-consequential or C5==1
    logging.info('Applying categories')
    mt = annotate_category_1(mt)
    mt = annotate_category_2(mt, new_genes=new_expression)
    mt = annotate_category_3(mt)
    mt = annotate_category_5(mt)
    mt = annotate_category_4(mt, plink_family_file=plink)
    mt = annotate_category_support(mt)

    mt = filter_to_categorised(mt)
    mt = checkpoint_and_repartition(
        mt,
        checkpoint_root=checkpoint_root,
        checkpoint_num=checkpoint_number,
        extra_logging='after filtering to categorised only',
    )

    # obtain the massive CSQ string using method stolen from the Broad's Gnomad library
    # also take the single gene_id (from the exploded attribute)
    mt = mt.annotate_rows(
        info=mt.info.annotate(
            CSQ=vep_struct_to_csq(mt.vep),
            gene_id=mt.geneIds,
        )
    )

    write_matrix_to_vcf(mt=mt)


if __name__ == '__main__':
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s %(levelname)s %(module)s:%(lineno)d - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S',
        stream=sys.stderr,
    )

    parser = ArgumentParser()
    parser.add_argument('--mt', required=True, help='path to input MT')
    parser.add_argument('--panelapp', type=str, required=True, help='panelapp JSON')
    parser.add_argument('--plink', type=str, required=True, help='Cohort Pedigree')
    parser.add_argument(
        '--clinvar', type=str, default='absent', help='Custom Clinvar Summary HT'
    )
    args = parser.parse_args()
    main(
        mt_path=args.mt, panelapp=args.panelapp, plink=args.plink, clinvar=args.clinvar
    )
